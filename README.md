# Algorithms Project Report

Implementation, time complexity analysis, and benchmarking of the following algorithms:

- [x] Quick Sort
- [x] Quick 3 Way Sort
- [x] Counting Sort
- [x] Quick Sort with random pivot
- [x] Tim Sort

## Project Structure

- [Quick Sort](/quick_sort)
- [Quick 3 Way Sort](/quick_3way_sort)
- [Counting Sort](/counting_sort)
- [Quick Sort with random pivot](/quick_sort_random_pivot)
- [Tim Sort](/tim_sort)
- [Project report](/docs)

## How it works

### How benchmarking works

The benchmarking process is now handled by a C++ executable. The general steps are:

1. Set process priority to the highest available to avoid interrupts (platform dependent).
2. Pin the process to one CPU core to avoid context switching (platform dependent).
4. Run the algorithm with different input sizes or max values, repeating it multiple times for accuracy.
5. Save the results to a CSV file.

### How plot.py works

1. Scans the input directory for all CSV files.
2. For each CSV file found:
    a. Loads the raw benchmark data. This includes columns like `length` (or `max_val`) and multiple time measurement columns (e.g., `time_0`, `time_1`, ...) which are expected to be in nanoseconds.
    b. Transforms the data:
        i. Converts all raw time measurements from nanoseconds to microseconds.
        ii. Calculates a single `time` metric for each data point by taking the median of the repetition time measurements, after removing outliers.
        iii. Calculates the standard deviation (`time_std`) of these time measurements.
    c. Parses the CSV filename to determine plot characteristics:
        - The plot title is typically formed from the initial parts of the filename (e.g., algorithm name, sample count, repetition count, and scaling type).
        - The x-axis variable (`length` or `max_val`) is inferred from keywords like "length" or "max" in the filename.
        - The plot scale (`linear` or `log`) is inferred from keywords like "exponential" (for log scale) in the filename.
    d. Generates a plot using the processed data and saves it as an SVG file in the output directory.

### How data is stored

All recorded data is stored in [.results](/.results) directory. Each algorithm has its own directory and inside it,
there multiple csv files with the results of the various runs.
The standard format for the file name is
`<algorithm_name>_<samples>_<repetitions>_<linear | exponential>_<length | max>_<windows | linux>.<csv | svg>`. The svg
files are the plots generated by the [plot.py](/plot.py) script and the csv files are generated by
the C++ benchmark executable.

Filename regex: `([a-z_]+)_\\d+_\\d+_(linear|exponential)_(max|length)_([a-z]+)\\.(csv|svg)`

Meaning of the filename parts:

- `<algorithm_name>`: The name of the algorithm being benchmarked
- `<samples>`: The number of samples (or row) measured in the benchmark
- `<repetitions>`: The number of times the algorithm was run for each sample
- `<linear | exponential>`: The type of scaling used in the benchmark. `plot.py` uses "exponential" to set a log scale.
- `<length | max>`: What is the variable being changed in the benchmark, length for the input array length and max for the maximum value in the input array. This determines the x-axis of the plot.
- `<windows | linux>`: The operating system used to run the benchmark.
- `<csv | svg>`: The file format of the file, csv for the raw data and svg for the plot.

The `plot.py` script uses these parts to configure the plot. For instance, the plot title is often constructed from `<algorithm_name> <samples> <repetitions> <linear | exponential>`.

### How data is stored in the CSV files

The CSV files generated by the C++ benchmark executable contain raw data from the benchmark runs. The `plot.py` script then processes this data. The columns typically include:

- `length`: The length of the input array (this was previously referred to as `size`).
- `min_val`: The minimum value in the input array (used for random input generation; its presence might depend on the benchmark setup).
- `max_val`: The maximum value in the input array. This is used as the x-axis variable if "max" is specified in the filename.
- `resolution`: The resolution of the timer used for measurements, in nanoseconds.
- `time_0`, `time_1`, ..., `time_N`: A series of columns where each column (e.g., `time_0`, `time_1`) stores the raw execution time in nanoseconds for one repetition of the algorithm for a given input configuration. The `plot.py` script processes these columns to calculate a median time (in microseconds) and standard deviation (in microseconds) for plotting.
