# Algorithms Project Report

Implementation, time complexity analysis, and benchmarking of the following algorithms:

- [x] Quick Sort
- [x] Quick 3 Way Sort
- [x] Counting Sort
- [x] Quick Sort with random pivot
- [ ] Tim Sort

## Project Structure

- [Quick Sort](/quick_sort)
- [Quick 3 Way Sort](/quick_3way_sort)
- [Counting Sort](/counting_sort)
- [Quick Sort with random pivot](/randomized_quick_sort)
- [Tim Sort](/tim_sort)
- [Project report](/docs)

## How to run

First, you need to install the dependencies:

```bash
pip install -r requirements.txt
```

Then, you can run the benchmarking tool:

```bash
python benchmark.py -i <input_folder>
```

### Arguments for benchmark.py

```bash
usage: Sorting Algorithms Benchmark [-h] -i INPUT [-o OUTPUT] [-s SAMPLES] [-r REPETITIONS] [-v] [--linear] [--by-max] [--max-val MAX_VAL] [--max-length MAX_LENGTH]

Benchmarking tool for the project

options:
  -h, --help            show this help message and exit
  -i, --input INPUT     Input directory for algorithm inputs
  -o, --output OUTPUT   Output directory for benchmark results
  -s, --samples SAMPLES Number of samples to get
  -r, --repetitions REPETITIONS Number of repetitions for each input length to run
  -v, --verbose         Increase output verbosity
  --linear              Use linear scaling instead of exponential
  --by-max              Benchmark by varying the maximum value of the input data
  --max-val MAX_VAL     Maximum value of the input data
  --max-length MAX_LENGTH Maximum length of the input data
```

### Arguments for plot.py

```bash
usage: plot.py [-h] [-i INPUT] [-o OUTPUT]

Plot benchmark data from CSV files

options:
  -h, --help            show this help message and exit
  -i INPUT, --input INPUT       Directory containing CSV files
  -o OUTPUT, --output OUTPUT    Output directory for plots
```

## How it works

### How benchmark.py works

1. Set process priority to the highest available to avoid interrupts
2. Pin the process to one CPU core to avoid context switching
3. Load the algorithm to benchmark and compile it using Cython
4. Start the benchmark part, runs the algorithm with different input sizes or max value (depends on input args), repeating it multiple times
5. Save the results to a CSV file

### How plot.py works

1. Load the CSV files from the input directory
2. Parse filename to get the algorithm name and other parameters
3. Generate a plot for each CSV file

### How data is stored

All recorded data is stored in [.results](/.results) directory. Each algorithm has its own directory and inside it, there multiple csv files with the results of the various runs.
The standard format for the file name is `<algorithm_name>_<samples>_<repetitions>_<linear | exponential>_<length | max>_<windows | linux>.<csv | svg>`. The svg files are the plots generated by the [plot.py](/plot.py) script and the csv files are generated by the [benchmark.py](/benchmark.py) script.

Filename regex: `([a-z_]+)_\d+_\d+_(linear|exponential)_(max|length)_([a-z]+)\.(csv|svg)`

Meaning of the filename parts:

- `<algorithm_name>`: The name of the algorithm being benchmarked
- `<samples>`: The number of samples (or row) measured in the benchmark
- `<repetitions>`: The number of times the algorithm was run for each sample
- `<linear | exponential>`: The type of scaling used in the benchmark
- `<length | max>`: What is the variable being changed in the benchmark, length for the input array length and max for the maximum value in the input array
- `<windows | linux>`: The operating system used to run the benchmark
- `<csv | svg>`: The file format of the file, csv for the raw data and svg for the plot

### How data is stored in the CSV files

The CSV files have the following columns:

- `size`: The size of the input array
- `min_value`: The minimum value in the input array (presence not guaranteed, it used only to give the minimum range for the random input generation)
- `max_value`: The maximum value in the input array (presence guaranteed)
- `time`: The time taken to run the algorithm in nanoseconds, the median between all repetitions
- `resolution`: The minimum measurable time in nanoseconds for the method used to measure the time
- `stdev`: The standard deviation of the time taken to run the algorithm
- `mad`: The median absolute deviation of the time taken to run the algorithm

## FAQ

### What is Cython

Cython is a static compiler for both the Python programming languages.
It allows writing C extensions for Python, which can be used to optimize the code.

By using Cython, we can write the algorithm in C and compile it to a Python module,
which can be imported and used in the benchmarking tool.

### Why using Cython

Because it allows using the flexibility of python to write the benchmarking tool
and use the speed and predictability of C to run the algorithms.
